{
  "language": "Solidity",
  "sources": {
    "contracts/Bridge/AvaxBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Token/IERC20.sol\";\n\ncontract AvaxBridge {\n  /* Selector to call the transfer function of an ERC20 */\n  bytes4 private constant TRANSFER_SELECTOR =\n    bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n  /* Selector to call the transferFrom function of an ERC20 */\n  bytes4 private constant TRANSFER_FROM_SELECTOR =\n    bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n\n  /* Represents the ERC20 token */\n  address public immutable avaxERC20;\n\n  /* Admin of the contract that is able to call `release()` */\n  address public admin;\n\n  /* Gets incremented with each `lock()`, indicates the transferCount\n    and prevents double processing the event */\n  uint public nonce;\n\n  /* Mapping to hold whether nonce is processed or not */\n  mapping(uint => bool) public nonceToIsProcessed;\n\n  /* Allows us to indicate whether it is a `release()` or `lock()` when emitting an event */\n  enum Type {\n    Release,\n    Lock\n  }\n\n  error NonceAlreadyProcessed(uint nonce);\n  error ERC20TransferFail();\n  error ERC20TransferFromFail();\n  error NotAdmin(address caller);\n  /*\n        Event that is emitted with both `release()` and `lock()`\n        Relayer listens to events emitted by `lock()`\n        Potential frontend application may want to listen to events emitted by `release()`\n    */\n  event Transfer(\n    address from,\n    address to,\n    uint amount,\n    uint time,\n    uint nonce,\n    Type indexed transferType\n  );\n\n  /* Modifier to allow some functions to be only called by admin */\n  modifier onlyAdmin() {\n    _onlyAdmin();\n    _;\n  }\n\n  function _onlyAdmin() private view {\n    if (msg.sender != admin) {\n      revert NotAdmin(msg.sender);\n    }\n  }\n\n  /* Constructor that sets admin as the sender and initializes the ERC20 token inside contract */\n  constructor(address _token) {\n    admin = msg.sender;\n    avaxERC20 = _token;\n  }\n\n  /* Function to allow setting a new admin */\n  function setAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n  }\n\n  function _safeTransfer(address token, address to, uint value) private {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(TRANSFER_SELECTOR, to, value)\n    );\n    if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\n      revert ERC20TransferFail();\n    }\n  }\n\n  function _safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint value\n  ) private {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(TRANSFER_FROM_SELECTOR, from, to, value)\n    );\n    if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\n      revert ERC20TransferFromFail();\n    }\n  }\n\n  /* Function that is called by the relayer to release some tokens after it is burned on the subnet */\n  function release(\n    address to,\n    uint amount,\n    uint subnetNonce\n  ) external onlyAdmin {\n    if (nonceToIsProcessed[subnetNonce]) {\n      revert NonceAlreadyProcessed(subnetNonce);\n    }\n    nonceToIsProcessed[subnetNonce] = true;\n\n    /* Bridge sends locked tokens to the `to` address therefore, releases the tokens */\n    // avaxERC20.transfer(to, amount);\n    _safeTransfer(avaxERC20, to, amount);\n\n    emit Transfer(\n      msg.sender,\n      to,\n      amount,\n      block.timestamp,\n      subnetNonce,\n      Type.Release\n    );\n  }\n\n  /*\n        Function that is called by the user to lock their tokens.\n        Relayer listens to the event emitted by this function and if the nonce is not processed,\n        it will call `mint()` of the SubnetBridge\n    */\n  function lock(address to, uint amount) external {\n    /* Send ERC20 tokens from msg.send (user) to bridge to lock the tokens */\n    /* Do not forget: sender should approve bridge address to do this */\n    _safeTransferFrom(avaxERC20, msg.sender, address(this), amount);\n\n    /* Event that is emitted for relayer to process */\n    emit Transfer(msg.sender, to, amount, block.timestamp, nonce, Type.Lock);\n    /* Increment the nonce to prevent double counting */\n    unchecked {\n      ++nonce;\n    }\n  }\n}\n"
    },
    "contracts/Bridge/ZateBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Token/INativeMinter.sol\";\n\ncontract SubnetBridge {\n  /* Selector to call the mintNativeCoin function of INativeMinter */\n  bytes4 private constant NATIVE_MINT_SELECTOR =\n    bytes4(keccak256(bytes(\"mintNativeCoin(address,uint256)\")));\n  /* Address to send tokens to burn them */\n  address public constant burnAddress = address(0x0);\n\n  address public constant nativeMinter =\n    address(0x0200000000000000000000000000000000000001);\n\n  /* Admin of the contract that is able to call `release()` */\n  address public admin;\n\n  /* Gets incremented with each `burn()`, indicates the transferCount\n    and prevents double processing the event */\n  uint public nonce;\n\n  /* Represents NativeMinterInterface */\n\n  /* Mapping to hold whether nonce is processed or not */\n  mapping(uint => bool) public nonceToIsProcessed;\n\n  /* Allows us to indicate whether it is a `mint()` or `burn()` when emitting an event */\n  enum Type {\n    Mint,\n    Burn\n  }\n\n  error InvalidBurnAmount(uint amount);\n  error NonceAlreadyProcessed(uint nonce);\n  error NativeMintFail();\n  error BurnFail();\n  error NotAdmin(address caller);\n\n  /*\n        Event that is emitted with both `mint()` and `burn()`\n        Relayer listens to events emitted by `burn()`\n        Potential frontend application may want to listen to events emitted by `mint()`\n    */\n  event Transfer(\n    address from,\n    address to,\n    uint amount,\n    uint time,\n    uint nonce,\n    Type indexed transferType\n  );\n\n  /* Modifier to allow some functions to be only called by admin */\n  modifier onlyAdmin() {\n    _onlyAdmin();\n    _;\n  }\n\n  function _onlyAdmin() private view {\n    if (msg.sender != admin) {\n      revert NotAdmin(msg.sender);\n    }\n  }\n\n  /* Constructor that sets admin as the sender */\n  constructor() {\n    admin = msg.sender;\n  }\n\n  /* Function to allow setting new admin */\n  function setAdmin(address newAdmin) external onlyAdmin {\n    admin = newAdmin;\n  }\n\n  function _safeNativeMint(address to, uint value) private {\n    (bool success, ) = nativeMinter.call(\n      abi.encodeWithSelector(NATIVE_MINT_SELECTOR, to, value)\n    );\n    if (!success) {\n      revert NativeMintFail();\n    }\n  }\n\n  function _safeBurn() private {\n    (bool success, ) = payable(burnAddress).call{value: msg.value}(\"\");\n    if (!success) {\n      revert BurnFail();\n    }\n  }\n\n  /* Function that is called by the relayer to mint some tokens after it is locked on the avax */\n  function mint(address to, uint amount, uint avaxNonce) external onlyAdmin {\n    if (nonceToIsProcessed[avaxNonce]) {\n      revert NonceAlreadyProcessed(avaxNonce);\n    }\n    nonceToIsProcessed[avaxNonce] = true;\n\n    _safeNativeMint(to, amount);\n\n    emit Transfer(\n      msg.sender,\n      to,\n      amount,\n      block.timestamp,\n      avaxNonce,\n      Type.Mint\n    );\n  }\n\n  /*\n        Function that is called by the user to burn their tokens.\n        Relayer listens to this event and if the nonce is not processed,\n        it will call `release()` of the AvaxBridge\n    */\n  function burn(address to) external payable {\n    if (msg.value == 0) {\n      revert InvalidBurnAmount(msg.value);\n    }\n\n    /* Send native token to 0x0 address, effectively burning native token */\n    _safeBurn();\n\n    /* Event that is emitted for relayer to process */\n    emit Transfer(msg.sender, to, msg.value, block.timestamp, nonce, Type.Burn);\n\n    /* Increment the nonce to prevent double counting */\n    unchecked {\n      ++nonce;\n    }\n  }\n}\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/Token/AvaxERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\n\n// A standard ERC20 token with maxSupply of 1 million\ncontract AvaxERC20 is ERC20 {\n  uint public constant MAX_SUPPLY = 1000000 ether;\n\n  // maxSupply is sent to the creator of the token\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC20(_name, _symbol, 18) {\n    _mint(msg.sender, MAX_SUPPLY);\n  }\n}\n"
    },
    "contracts/Token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC20 {\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n"
    },
    "contracts/Token/INativeMinter.sol": {
      "content": "// (c) 2022-2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface NativeMinterInterface {\n  // Set [addr] to have the admin role over the minter list\n  function setAdmin(address addr) external;\n\n  // Set [addr] to be enabled on the minter list\n  function setEnabled(address addr) external;\n\n  // Set [addr] to have no role over the minter list\n  function setNone(address addr) external;\n\n  // Read the status of [addr]\n  function readAllowList(address addr) external view returns (uint256);\n\n  // Mint [amount] number of native coins and send to [addr]\n  function mintNativeCoin(address addr, uint256 amount) external;\n}\n"
    },
    "solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}